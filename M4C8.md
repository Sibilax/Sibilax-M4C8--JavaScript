# M4C8 -  Conceptos de JavaScript

![Img](Images/js.jpg)

## 1. ¿Qué tipo de bucles hay en JS?

En JavaScript, existen varios tipos de bucles, estos realizan tareas de manera repetida, esto no sólo facilita la tarea del desarrollador sino que también la hace más eficiente.Los bucles evitan además que haya que repetir código o escribir código innecesario, minimizando la probabilidad de errores y haciendo que el código sea más legible.

### Los bucles más comunes son:

### A) **Bucle for**: 

Este bucle repetirá una tarea hasta que la condición que hayamos determinado sea evaluada como falsa. Es decir, mientras mi condición sea verdadera, el bucle seguirá iterando los elementos y realizando el comportamiento que le hayamos indicado (por ejemplo, imprimirlos).

Un bucle for puede utilizarse para iterar diferentes elementos como arrays o strings, por ejemplo.

Este tipo de bucle se compone por los siguientes elementos:
- Un elemento a iterar.
- La palabra reservada **for**.
- Una inicialización, esto es, la variable de iteración a la que se asigna el elemento por el que debe comenzar a iterar. En el ejemplo a continuación, como queremos que empiece por el primer elemento, indicaremos el índice 0.
- Una condición, que será evaluada tras cada iteración. Si es verdadera, nuestro bucle continuará iterando y si es falsa se detendrá.
- Una expresión de iteración, que lo que hace es actualizar el estado del contador para que la iteración se realice en el elemento siguiente, por ejemplo.
- Lo que se espera del bucle (sea que imprima o retorne algo).

**El bucle for tiene la siguiente estructura:**

```js
const arr = [1, 2, 3, 4, 5]; //elemento a iterar

for (let i = 0; //inicializo el contador en cero para que inicie desde el primer elemento del array
  i < arr.length; //condición: que itere los elementos mientras el elemento iterado sea menor que el numero de elementos en el array
  i++) {//que incremente el contador en uno para que itere el siguiente elemento, i++ sería equivalente a decir "i = i + 1"
  console.log(arr[i]); // Imprime cada elemento del array: 1, 2, 3, 4, 5 - arr[i] corresponde al elemento que se está iterando
}
```
### B) **Bucle while**: 

El bucle while en JS se ejecutará en tanto la condición que hemos establecido sea verdadera. A diferencia del bucle for, en el cual determinamos el número de iteraciones (en el ejemplo anterior el límite era la longitud del array), el bucle while no necesita esa información. 

Este bucle es especialmente útil cuando no sabemos cuantas veces se va a iterar, ya que en el bucle while esto va a depender de la condición que hayamos determinado. Sin embargo, es fundamental que nuestra condición esté establecida de tal manera que en algún momento resulte falsa, de lo contrario, generará un bucle infinito.

**Este tipo de bucle se compone por los siguientes elementos:**
- Un elemento a iterar
- Una inicialización, la variable de iteración a la que se asigna el elemento por el que debe comenzar a iterar. En el ejemplo a continuación, como queremos que empiece por el primer elemento, indicaremos el índice 0. A diferencia del bucle for, esta se establece antes de crear el bucle.
- La palabra reservada **while**.
- Una condición, que será evaluada tras cada iteración. Si es verdadera, nuestro bucle continuará iterando y si es falsa se detendrá.
- Lo que se espera del bucle (sea que imprima o retorne algo, por ejemplo).
- Una expresión de iteración, que lo que hace es actualizar el estado del contador para que la iteración se realice en el elemento siguiente, por ejemplo.


```js
const arr = [1, 2, 3, 4, 5]; //elemento a iterar

// Inicializamos el índice 0 para recorrer el array
let i = 0;


while (i < arr.length) {// Mientras el índice sea menor que la longitud del array, el bucle iterará
  console.log(arr[i]); // Imprime cada elemento del array: 1, 2, 3, 4, 5 - arr[i] corresponde al elemento que se está iterando
  i++; // Incrementamos el contador para iterar al siguiente elemento
}
```
### C) **Bucle do...while**: 

Este bucle es similar al bucle while. Sin embargo, este bucle es particularmente útil, ya que nos garantiza que iterará cada elemento por lo menos una vez. Esto se debe a que este bucle evalúa la condición después de haber ejecutado el bloque de código. Esto nos garantiza que iterará por lo menos una vez, incuso si la condición que hemos establecido es falsa.

**Este tipo de bucle se compone por los siguientes elementos:**
- Un elemento a iterar. 
- Una variable de iteración que establece el contador en el índice del elemento a partir del cual queremos iterar. Generalmente 0, si queremos iterar desde el primer elemento.
- La palabra reservada **do**. Inicia el bloque de código que se ejecutará al menos una vez antes de verificar la condición de salida.
- Lo que quiero que suceda tras cada iteración, normalmente que se incrementa (o decrementa) el índice del elemento iterado en 1, para que así se itere el siguiente elemento.
- La acción que yo quiero que se realice tras iterar cada elemento, sea retornar o imprimir el valor, por ejemplo.
- La palabra reservada **while**. Indica que después de ejecutar el bloque de código, se evaluará la condición especificada. 
- La condición de salida, será ahora evaluada después de cada iteración. Si es falsa, el bucle se detiene.

```js
let i = 0;// variable de iteración, inicia en 0
do {
  i = i + 1; // tras cada iteración se incrementa el contador en 1 para pasar al siguiente elemento
  console.log(i);//imprime cada elemento que itere
} while (i < 10); // verifica la condición, si es falsa se detiene

```
En este ejemplo, la variable i se utiliza como contador y también como el elemento que se itera en el bucle do-while. 

El bucle iterará **let i** mientras esta sea menos a 10, e imprimirá los números del 1 al 10. Lo que imprime no es el índice de **let i** sino el elemento iterado, y como hemos indicado que **i** se incremente tras cada iteración, esta irá cambiando su valor tras cada una de ellas.

Veamos otro ejemplo:

```js
const numeros = [1, 2, 3, 4, 5]; // Array de números a iterar
let i = 0; // Variable de iteración, inicia el contador en 0

do {
  console.log(numeros[i]); // Imprime el elemento actual del array en cada iteración: 1, 2, 3, 4, 5
  i++; // Incrementa el índice en 1 para pasar al siguiente elemento
} while (i < numeros.length); // Verifica la condición: cuando el índice deje de ser menor que la longitud del array, se detiene

```

En este ejemplo, como se trata de un array, al acceder a sus elementos se utiliza la notación de corchetes [] **(numeros[i])**. A diferencia del ejemplo anterior, en el que usaban paréntesis curvos.

### D) **Bucle for in**: 

Este bucle se utiliza para iterar sobre las propiedades enumerables de un objeto. Las propiedades enumerables son aquellas que se pueden listar y a las que se puede acceder utilizando métodos como Object.keys() u Object.values(), por ejemplo. Esto lo hace sumamente útil cuando necesitamos trabajar con objetos y acceder a las claves.

**Este tipo de bucle se compone por los siguientes elementos:**
- Un objeto a iterar. El bucle for...in recorrerá tanto sus claves como sus valores.
- La palabra reservada **for**
- Una variable de iteración que representará el elemento iterado en cada iteración.
- La palabra reservada **in**
- El objeto en el que se realizará la iteración.
- Lo que se espera del bucle (sea que imprima o retorne algo).

Con esto primero presentaremos el objeto a iterar y le indicaremos al bucle que: para cada elemento iterado dentro de ese objeto, queremos que realice la actividad que le indiquemos. En el ejemplo a continuación será simplemente imprimir las claves, seguidas de dos puntos y el valor correspondiente a esa clave.

```js
const persona = {//objeto a iterar
  nombre: 'Ana',
  edad: 39,
  correo: 'Ana@gmail.com'
};

for (let clave in persona) { //para cada elemento de la variable persona
  console.log(clave + ': ' + persona[clave]);//imprime la clave: y el valor correspondiente --> 'nombre: Ana', 'edad: 39'...
}
```

Cabe mencionar que este tipo de bucle, aunque podría utilizarse para iterar arrays, no es recomendado ya que puede presentar comportamientos inesperados.

### E) **Bucle for of**: 

Este bucle se utiliza para iterar sobre estructuras de datos que sean iterables: arrays, strings, objetos iterables. Es importante mencionar que los objetos en JS no son iterables, sin embargo, los objetos iterables son aquellos objetos a los que se les ha implementado un método especial que permite iterar sobre sus elementos.


**Este tipo de bucle se compone por los siguientes elementos:**
- Un objeto a iterar. En este caso un array.
- La palabra reservada **for**
- Una variable de iteración que representará el elemento iterado en cada iteración (nombre)
- La palabra reservada **of**
- El elemento en el que se realizará la iteración(el array nombres).
- Lo que se espera del bucle. En ese caso que se imprima cada elemento.

```js
const nombres = ['Santos', 'Carmen', 'Gonzalo']; //elemento a iterar

for (const nombre of nombres) { // para cada elemento(nombre) en el array (nombres)
  console.log(nombre); // imprimirá cada elemento: 'Santos', 'Carmen', 'Gonzalo'
}
```

## 2. ¿Cuáles son las diferencias entre const, let y var?

Existen tres tipos de declaraciones de variables en JavaScript:

### Var

Var era la opción utilizada en JS para declarar variables antes de que otras alternativas como let y const existieran.

**Ejemplo**

```Js
var usuario = 'Tom';
```
### ¿Por qué se ha dejado de utilizar?

Var permite redeclarar y reasignar valores sin generar errores. Si bien, a simple vista, esto puede parecer ventajoso porque parecería dar mayor flexibilidad, nos hará más propensos a cometer errores, ya que si creamos una variable var con el mismo nombre que una que hayamos creado anteriormente, esta reasignará su valor y provocará errores difíciles de detectar.

Por ejemplo, si creo una variable var con un valor específico y utilizo esa variable en una función obtendré el comportamiento que he determinado:

```js

var usuario = 'Tom';

function saludar() {
  console.log(`Hola ${usuario}`);
}

saludar();// Llamamos a la función saludar para que muestre el mensaje 'Hola Tom'

```

Pero si unas líneas de código después, creyendo estar creando una nueva variable, por error utilizo el mismo nombre y le asigno un valor, JS no me indicará que esa variable ya existe. 

Unas cuantas líneas de código después, cuando vuelva a llamar a la función, esta ya no tendrá el comportamiento que yo había anticipado:

```js
var usuario = 'Tom';

function saludar() {
  console.log(`Hola ${usuario}`);
}


saludar();// Previamente imprimía "Hola Tom"
console.log('unas lineas de código más tarde');
console.log('al crear una nueva variable con el mismo nombre');
var usuario = 'Tina';
console.log('y reasignar su valor por error');
console.log('no sabré porqué mi función no se comporta como debería');
saludar(); //Ahora imprime "Hola Tina" y tendré que buscar en mi código dónde está el error
```

En este caso se trata de un ejemplo extremadamente simple, pero en casos donde el código es más extenso y complejo, esto puede resultar muy difícil de resolver e identificar, en especial porque var no indicará ningún error. 

Además de esto, las variables var pueden sufrir **hoisting** o elevación. Esto significa que la variable var se procesa antes de que se ejecute cualquier otra parte del código. 

Esa variable es "izada" al inicio del código, pero esto sólo afecta a la declaración y no al valor que le hemos asignado. Por lo que una variable var que hemos definido (a la que le hemos asignado un valor) será elevada al inicio del código como undefined, es decir, como si aún no le hubiéramos asignado ningún valor.

Esto significa que esa variable que declaramos dentro de nuestra función, por ejemplo, para que fuera de ámbito local, ahora se ha vuelto de ámbito global y ni siquiera tiene el valor que le habíamos asignado inicialmente.

Esto provocará errores si pretendemos acceder a esa variable antes de asignarle un valor (ya que estará sin definir - undefined). 

Sumado a eso, cuando cargue el resto del código, y dentro de él la variable var que hemos definido dentro de la función ocurrirán dos cosas:
- Esta será una variable local (tal como era nuestra intención inicial).

- Pero además ocurrirá un comportamiento inesperado. Ese valor del la función local definirá también esa función global que jamás tuvimos intención de crear, y que ha sido un mero efecto colateral de haber utilizado var para declarar nuestra variable.

Por razones como esta, el uso de var está desaconsejado en JS, y se prefieren opciones como let y const para declarar variables.

### let

**Ejemplo**
```Js
var usuario = 'Tom';
```

Estas variables tienen un ámbito de bloque, esto quiere decir que su espectro se limita al bloque de código en el que se han declarado {}; dicho de otra manera, se trata de funciones de ámbito local. Si declaramos una variable let dentro de una función, esta no podrá actuar o ser llamada fuera de esa función. Esto no significa que una variable declarada con let no pueda ser de ámbito global, sólo significa que una vez declarada dentro de un bloque de código, como una función, a diferencia de var, estas variables sólo tendrán ámbito local. 

Volviendo a nuestro ejemplo anterior. Vamos a crear una variable let dentro de la función y a imprimir usando una plantilla literal (`Hola ${usuario}` sustituirá ${usuario por el valor de dicha variable}).

```js
function saludar() {
  let usuario = 'Tom';

  console.log(`Hola ${usuario}`);
}

saludar();// Imprime 'Hola Tom'

```
Hasta aquí todo ha ocurrido como esperábamos. Sin embargo, si intento acceder al valor de esa variable desde fuera de la función en la que la he declarado, esto no será posible, y obtendré un error que indica que esa variable no ha sido definida.

```js
function saludar() {
    let usuario = 'Tom';
    
    console.log(`Hola ${usuario}`);
  }
  
saludar();// Imprime 'Hola Tom'


console.log(`Hola ${usuario}`);// imprime: usuario is not defined
```

Como hemos mencionado previamente, let me permite además crear variables de ámbito global. A diferencia de la variable anterior, esta estará disponible en todo nuestro código, y puedo acceder a ella incluso desde dentro de nuestra función. Para ello creo una variable let fuera de la función:

```js
let otroUsuario = 'Rita';

function saludar() {

    let usuario = 'Tom';
  
    console.log(`Hola ${usuario}`);
  
    console.log(`Hola ${otroUsuario}`);
  }
  
saludar();//'Hola Tom' y 'Hola Rita'. 

```
A diferencia de las variables var, que mencionamos anteriormente, las variables let **no se pueden redeclarar en el mismo ámbito**. 

Ahora, cabe aclarar que JS sí permite declarar una variable local let y otra global con el mismo nombre.

Si en el ejemplo anterior hubiéramos llamado igual a nuestras dos variables, la única que se hubiera imprimido sería la variable global. Esto puede provocar errores difíciles de identificar por lo que es aconsejable evitar hacerlo.

Al igual que las variables que declaramos con var, las variables que declaramos con let permiten reasignarles valores, aunque en general esto no se recomienda ya que puede afectar nuestro código de manera negativa. Cuando creamos nuestro código y asignamos valores, podemos en gran medida, prever su comportamiento; sin embargo, si nuestra variable comienza a cambiar de valores, nos puede resultar difícil recordar cómo y dónde la hemos modificado. Esta capacidad de reasignación es una de las diferencias principales entre let y const. 

Las variables let también se ven afectadas por el **hoisting** pero de manera diferente a lo que sucedería con las variables var. Estas no se inicializan como undefined, sino que su inicialización se pospone hasta que se alcance su declaración en el código, o dicho de otra forma, let no se estará disponible usar hasta que no cargue el valor que se le ha asignado.

**const**

Estas variables se utilizan para declarar constantes. Las constantes son variables de solo lectura, esto quiere decir que no se les puede reasignar valor, no se pueden modificar. A diferencia de lo que ocurría con las variables var, intentar reasignar un valor a una constante generará un error.

El hoisting afecta a const y let de manera similar, su inicialización también se pospone hasta que se alcance su declaración en el código. O sea, no estará disponible para ser usada en tanto no se haya declarado.

Las variables const son recomendables para declarar valores que deben mantenerse constantes a lo largo del programa. Estas garantizan que no podamos reasignar valores a nuestra variable por error, cosa que sí podría ocurrir con var y let.

## 3. ¿Qué es una función de flecha?

Una función de flecha, o arrow function, es un tipo de función sumamente práctica en JS. Estas son mucho más concisas y simples que las funciones tradicionales, las funciones anónimas e incluso que las expresiones de función.

### Características de las funciones flecha:

- Tienen una sintaxis escueta, por lo que hacen posible escribir funciones más fáciles de entender y con mucho menos código. Esto es, por un lado, una ventaja, ya que tienen una sintaxis simplificada respecto al resto de funciones pero, por otro lado, implica que son más limitadas que el resto de las funciones en cuanto al tipo de comportamientos que permiten implementar.

- Suelen asignarse a variables para poder utilizarlas posteriormente.

- Son funciones anónimas, a diferencia de las funciones tradicionales que suelen declararse con la palabra function y el nombre que designemos para esa función.

- aceptan parámetros, incluidas expresiones de función, lo cual les otorga mayor flexibilidad. 

**Función nombrada vs función flecha**:

### Función nombrada:

```js
function saludar(nombre) {
  return `¡Hola, ${nombre}! ¿Cómo estás?`;
}

console.log(saludar('Carlos'));
```

La función nombrada requiere una sintaxis más extensa. Si bien este es un ejemplo muy simple, podemos ver que hace falta utilizar la palabra reservada function al momento de declararla, además debemos darle un nombre, utilizar llaves {} y retornar lo que queremos que devuelva.

### Función flecha:

```js
const saludarFlecha = nombre => `¡Hola, ${nombre}! ¿Cómo estás?`;

console.log(saludarFlecha('Carlos'));

```

A simple vista se aprecia que la función flecha tiene una sintaxis mucho más simplificada: no requiere ser declarada utilizando la palabra function, es una función anónima por lo que no requiere un nombre, si sólo tiene un parámetro (como en este caso) es opcional utilizar paréntesis y, si solo hay una expresión de retorno (si solo devuelve una cosa), no hace falta utilizar llaves {} o return.

### Sintaxis de una función flecha

**La sintaxis de la función flecha va a variar según el caso:**

a. Funciones flecha con un único parámetro:

```js
const saludarFlecha = nombre => `¡Hola, ${nombre}! ¿Cómo estás?`;

console.log(saludarFlecha('Carlos'));

```
En este caso se trata de una función flecha asignada a una variable 'const saludarFlecha'. Esta función contiene un parámetro 'nombre', como esta función contiene un único parámetro podemos omitir utilizar paréntesis alrededor del mismo. 

Luego la flecha, que será la que indique donde comienza a definirse el comportamiento esperado. En este ejemplo queremos que devuelva un saludo con el parámetro anterior al que se pasará argumento cuando imprimamos con console.log y se lo indiquemos. 

La función flecha que hemos creado sólo tiene una línea de retorno, solo va a devolver una cosa: `¡Hola, ${nombre}! ¿Cómo estás?`. Por ello no es necesario utilizar ni llaves {}, ni return.

Finalmente imprimiremos, llamaremos a nuestra función almacenada en la variable saludarFlecha() y le pasaremos un nombre como argumento.

b. Funciones flecha con múltiples parámetros:

```js
const sumar = (a, b) => {
    return a + b;
  };

  console.log(sumar(3,5))// Imprime 8
```
Esta es una función flecha que contiene dos parámetros, la sintaxis es similar a la anterior pero hemos usado los paréntesis (que no se pueden omitir cuando hay mas de un argumento), y hemos usado llaves y return, que sí podrían omitirse, como veremos a continuación.

```js
const sumar = (a, b) => a + b;

console.log(sumar(3, 5)); // Imprime 8
```
En este caso, las llaves y return se pueden omitir porque esta función sólo tiene una expresión de retorno, es decir que solo generará un comportamiento, que es sumar a + b. 

Ahora veamos un caso en el que nuestra fucnión flecha realizará dos operaciones distintas, una suma y una resta y en la que no pueden omitirse ni los paréntesis ni return:

```js
const operaciones = (a, b) => {
  let suma = a + b;
  let resta = a - b;
  return { suma: suma, resta: resta }; // Se retorna un objeto con las operaciones
};

const resultados = operaciones(5, 3);
console.log(resultados); // Imprime: { suma: 8, resta: 2 }
```
return en este caso devolverá un objeto con dos pares clave-valor, uno con la clave suma y el valor correspondiente al resultado (que dependerá de los argumentos que hayamos pasado) y otro con la clave resta y el valor que corresponda en ese caso.

c. Función flecha sin parámetros:

Estas funciones son útiles cuando necesitamos una función que realice una acción específica pero no requiere recibir ningún dato o argumento externo para hacerlo. Realizan simplemente la tarea que le indiquemos, en este ejemplo simplemente imprimirá '¡Hola usuario!'.

```js
const saludar = () => {
  console.log('¡Hola usuario!.');
};

saludar();// Imprime '¡Hola usuario! .'
```

### Algunas ventajas de utilizar funciones flecha:

- Mejor comprensión del código, el código es sencillo, legible y fácil de comprender.

- Son útiles para funciones que realizan una sóla acción, esto evita código extenso y repetitivo y evita los posibles errores que esto pueda suponer.

- Pueden ser usadas como argumentos de otras funciones.

## 4. ¿Qué es la deconstrucción de variables?

La **deconstrucción de variables**, también conocida como desestructuración, es una herramienta sumamente útil, ya que nos permite realizar múltiples tareas en apenas unas pocas líneas de código:

- Manejar de objetos y arrays, ya que nos permite desempaquetar el contenido de estos en apenas unas líneas de código. Esto las hace más legibles y hace nuestro código más conciso.

- Intercambiar los valores de dos variables de una forma eficiente y legible

### Desestructuración de variables para intercambiar sus valores

Imaginemos que tenemos dos variables, en una se almacena el nombre de un usuario y en otra el nombre del administrador. 

```js
let admin = 'Ana';
let usuario = 'Juan';
```
Ahora, supongamos que por alguna razón necesitamos invertir esos roles. Que 'Ana' pase a ser usuario y 'Juan' administrador. En otras circunstancias esto requeriría varias lineas de código. Sin embargo, con la desestructuración podemos hacerlo en una única linea de código.

Para ello comenzaremos por pasar los nombres de nuestras variables entre corchetes [] en el orden en el que se encuentran, y asignarlos al cambio que queremos, esto último se hace pasando los valores en el orden que los necesitamos y nuevamente entre corchetes[].

Para nuestro ejemplo las variables actuales serían:  [admin, usuario] y lo que necesitamos es invertir sus roles, así que lo asignaremos a [usuario, admin] de la siguiente manera:

```js
let admin = 'Ana';
let usuario = 'Juan';

[admin, usuario] = [usuario, admin];

console.log(admin);// Imprimirá 'Juan'
console.log(usuario);// Imprimirá 'Ana'

```

Al imprimir nuestras variables veremos que los valores se han invertido.

### Desestructuración de Arrays

**¿Para qué sirve?**

Sirve para extraer los valores de un array y asignarlos a variables individuales.

**¿Cómo se usa?**

Depende del caso. Supongamos que tenemos un array con tres elementos a los que queremos acceder para almacenarlos cada uno en una variable. Lo que haremos será crear una variable, por ejemplo const, y entre corchetes establecer los nombres que queremos para esas tres variables. Una vez hecho esto le asignaremos el array que queremos desestructurar. 

### Ejemplo:

```js
//Variable que contiene el array a desestructurar
const arr = [
    'un elemento',
    'otro elemento',
    'último elemento'
]
// Desestructuración 
const [variableUno, variableDos, variableTres] = arr;

//Imprimo las nuevas variables 
console.log(variableUno); //'un elemento'
console.log(variableDos); //'otro elemento'    
console.log(variableTres);//'último elemento'
```

En este ejemplo hemos utilizado tres variables, pero podrían haber sido más o menos, en función de la cantidad de elementos de nuestro array. De este modo, cada una de las variables contendrá uno de los elementos del array. 

### Desestructuración de arrays usando el operador de propagación

Ahora, podría darse el caso de que tengamos múltiples elementos en el array pero sólo necesitemos usar los dos primeros valores dentro de él. En ese caso no tendría sentido crear tantas variables como elementos haya. En ese caso lo que puedo hacer es crear una variable para cada elemento que necesito, supongamos que los primeros dos, y almacenar el resto de elementos en una única variable.

Para hacerlo, la sintaxis es exactamente igual que la anterior: creamos una variable, por ejemplo const, y entre corchetes establecemos los nombres que queremos para esas dos variables que vamos a utilizar. Para la tercera, que será la que almacene todos los elementos del array que no vamos a utilizar pondremos tres puntos '...' antes del nombre de la variable, y al igual que lo hicimos en el ejemplo anterior, le asignaremos el array que queremos desestructurar, en este caso 'animales'. 

Esta última variable en la que almacenamos el resto de elementos devolverá un array.

```js
//Variable que contiene el array a desestructurar
const animales = [
    'lobo',
    'loro',
    'león',
    'tigre',
    'gato'
]

//Desestructuración con operador de propagación
const [canidos, aves, ...felinos] = animales;

//imprimimos
console.log(canidos); //'lobo'
console.log(aves); // 'loro'
console.log(felinos); //['león','tigre','gato']
```

Tal como lo mencionamos en el ejemplo anterior, el número de variables que creemos dependerá de nuestras necesidades.

### Desestructuración de objetos

En los dos ejemplos anteriores hemos trabajado la desestructuración en arrays, sin embargo, la desestructuración también puede aplicarse a objetos. En este caso la forma de trabajar es levemente diferente, ya que desestructuraremos el objeto a partir de sus claves. 

La sintaxis es muy similar a la anterior: creo una variable, en este caso const, con los nombres de mis nuevas variables, estos deberán coincidir con las propiedades del objeto que deseo que contengan. A diferencia de los arrays anteriores, para los que utilizamos corchetes [], para los objetos utilizaremos llaves {}. Luego podemos imprimir nuestras nuevas variables.

```js
//Variable que contiene el objeto a desestructurar
const persona = {
    nombre: 'Rita',
    edad: 20,
    ciudad: 'Caracas',
  };
  
//Desestructuración 
const { nombre, edad, ciudad } = persona;

//Imprimo las nuevas variables
console.log(nombre); // 'Rita'
console.log(edad); // 20
console.log(ciudad); // 'Caracas'

```
### Desestructuración de objetos usando el operador de propagación

La desestructuracón de un objeto utilizando el operador de propagación es muy similar a las mencionadas previamente. Creo una variable, en este caso const, y donde iría el nombre de esa variable debo pasar, etre llaves {}, los nombres de las variables que usaré para almacenar el contenido de mi objeto. Esos nombres deben coincidir con las claves del valor a almacenar en ellas. Si quiero almacenar el contenido de la propiedad 'nombre', mi variable debe llevar ese mismo nombre. 

En este caso sólo quiero almacenar la propiedad nombre y la propiedad edad, por lo que crearé una variable para cada una. El resto de los datos los almacenaré en una única variable, y aquí es donde utilizamos el operador de propagación. Para ello, utilizamos la sintaxis de los tres puntos '...' antes del nombre de la variable que va a almacenar toda la información que no nos interesa.

```js
//Variable que contiene el objeto a desestructurar
const persona = {
  nombre: 'José',
  edad: 34,
  ciudad: 'Lima',
  profesion: 'Docente',
};

//Desestructuración con operador de propagación
const { nombre, edad, ...infoExtra } = persona;

// Imprimo las nuevas variables
console.log(nombre); // 'José'
console.log(edad); // 34
console.log(infoExtra); //Imprime un objeto con la info adicional { ciudad: 'Lima', profesion: 'Docente' }
```
### Desestructuración de objetos anidados

Del mismo modo que hemos podido acceder a las propiedades de un objeto y almacenarlas en su propia variable, podemos hacerlo con un objeto anidado, esto es, con un objeto que se encuentra almacenado dentro de otro objeto. En el siguiente ejemplo tendremos el objeto persona y, anidado dentro de él, el objeto dirección:

```js
const persona = {
    nombre: 'Sandra',
    edad: 40,
    pais: 'Alemania',
    direccion: {
      calle: 'Linden',
      ciudad: 'Berlin',
      codigoPostal: '12345'
    }
  };
```

Ahora imaginemos que queremos acceder a ciertos datos de nuestro objeto persona, por ejemplo el nombre y la edad. Ya hemos visto como hacerlo, pero ¿qué pasa si quiero además acceder a alguna propiedad del objeto dirección, como el código postal y la ciudad, por ejemplo?

En ese caso, lo que necesitaremos es, primero crear nuestras variables de acuerdo a las propiedades a las que queremos acceder, hemos mencionado nombre, edad y dirección. Lo haremos tal y como lo hemos hecho en el ejemplo anterior.

```js
const { nombre, edad, direccion} = persona;
```
Ahora, una vez hecho esto, debo indicar con dos puntos y la sintaxis de llaves {} a que propiedades dentro de mi objeto anidado (direccion) deseo acceder. En este caso accederemos a la ciudad y el código postal. Con esto estoy indicando que de dentro del objeto 'direccion', las propiedades que deseo desestructurar son 'ciudad' y 'codigoPostal'.

```js
const { nombre, edad, direccion: {ciudad, codigoPostal}} = persona;
```
Luego ya podemos imprimir nuestras nuevas variables. Debemos recordar que en el caso de nuestro objeto persona debemos imprimir nuestras variables por el nombre que les hemos dado(nombre, edad). Pero en el caso del objeto anidado, imprimiremos usando el nombre de la propiedad o las propiedades que hemos desestructurado: 'ciudad' y 'codigoPostal' en este caso.

```js
console.log(nombre); // 'Sandra'
console.log(edad); // 40
console.log(ciudad); // 'Berlin'
console.log(codigoPostal); // '12345'
console.log(ciudad, codigoPostal);//'Berlin', '12345'
```
## 5. ¿Qué hace el operador de extensión en JS?

En JavaScript, el operador de extensión, con la sintaxis de los tres puntos (...) que hemos mencionado anteriormente(pregunta 4), también es conocido como operador de propagación, y tiene varias funciones:

a. Permite desestructurar arrays y objetos, tal y como lo vimos en la pregunta anterior (remitirse a pregunta, sección: Desestructuración de arrays usando el operador de propagación).

b. Permite la combinar arrays y objetos:

- puedo combinar dos arrays existentes en un único array:

```js
const arr1 = [1, 2, 3];
const arr2 = [4, 5];
const arrMixto = [...arr1, ...arr2];

console.log(arrMixto); // imprime [1,2,3,4,5]

```

- puedo combinar dos objetos existentes en un único objeto:

```js
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const objMixto = { ...obj1, ...obj2 };

console.log(objMixto); // Imprime { a: 1, b: 2, c: 3, d: 4 }

```

Sólo necesito crear una nueva variable y asignarle las dos variables que quiero unir utilizando la sintaxis de los tres puntos '...' antes del nombre de cada una. Si se trata de arrays, esto irá entre corchetes [], mientras que si se trata de objetos irá entre llaves {}.**
const objMixto = { ...obj1, ...obj2 };**

Si intentara realizar esta combinación sin utilizar el operador de propagación con la sintaxis de los tres puntos, obtendría un tercer array con dos arrays anidados, o un tercer objeto con dos objetos anidados respectivamente:

```js
//array
const arr3 = [1, 2, 3];
const arr4 = [4, 5];
const arrAnidado = [...arr3, ...arr4];

console.log(arrAnidado); // imprime [1, 2, 3, 4, 5]

//objeto
const obj3 = { a: 1, b: 2 };
const obj4 = { c: 3, d: 4 };

const objsAnidados = { obj3, obj4 };

console.log(objsAnidados); // Imprime { obj3: { a: 1, b: 2 }, obj4: { c: 3, d: 4 } }
```
c. Permite realizar copias superficiales de arrays y objetos:

La ventaja de este tipo de copia radica en que al modificarlas, no se modifica el array/objeto original.

```js
// Copiar arrays
const arrOriginal = [1, 2, 3];
const arrCopia = [...arrOriginal];
console.log(arrCopia); // [1, 2, 3]

// Copiar objetos
const objOriginal = { x: 1, y: 2 };
const objCopia = { ...objOriginal };
console.log(objCopia); // { x: 1, y: 2 }
```
d. Pasar Argumentos a Funciones:

Nos permite pasar un número indefinido de argumentos a nuestra función. Estos pueden pasarse como argumentos separados o como un array.

```js
function saludar(...nombres) {//indico que el numero de args puede variar
  console.log(`¡Hola a todos!`);// imprime ¡Hola a todos!
  for (const nombre of nombres) {
    console.log(`Hola, ${nombre}!`); // imprime el saludo para cada nombre en la lista de argumentos
  }
}


saludar('Juan', 'María', 'Daniel');//aquí paso el número de argumentos que hagan falta
```

## 6. ¿Qué es la programación orientada a objetos?

La programación orientada a objetos(POO, u OOP en inglés), es un modelo de programación informática que utiliza objetos para organizar el diseño de software, a diferencia de modelos de otros paradigmas que utilizan básicamente funciones y lógica. 

En el caso de JS, se trataba más de un tipo de programación orientada a funciones que a objetos por lo que carecía de opciones nativas para utilizar este paradigma, en consecuencia, se implementaron soluciones alternativas como utilizar funciones como clases. Podemos decir que JS ha evolucionado para adaptarse a la programación orientada a objetos y ahora es posible adoptar más fácilmente este enfoque.

La programación orientada a objetos, pretende organizar nuestro código como si fuera una colección de objetos que se relacionan unos con otros. No es exclusiva de ningún lenguaje de programación. Estos objetos poseen características propias(atributos o propiedades) y comportamientos (métodos), y se relaciona entre ellos para realizar las tareas o resolver los problemas que el programador les designe dentro del programa. Esto hace nuestro código más legible, fácil de mantener y capaz de ser reutilizado.

### En la programación orientada a objetos existen un número de conceptos clave:

### Clases:

Las clases son fundamentales en POO. Una clase sería equivalente al plano de una casa, pueden crearse múltiples casas utilizando el mismo plano. Estas pueden diferir en algunas de sus características (atributos), pero a grandes rasgos, todas han sido creadas a partir del mismo patrón.

Las clases permiten preparar una especie de plantilla de los objetos o instancias que luego serán creadas. Además de ellos, también es posible definir funciones dentro de ellas.

**Ejemplo**

```js

class Alumnos { // Declaración de una clase llamada Alumnos
  constructor(nombre, edad) {  // Constructor para inicializar objetos de la clase
    this.nombre = nombre; // Atributo nombre al que se le asigna el parámetro nombre
    this.edad = edad; // Atributo edad al que se le asigna el parámetro edad
  }

  mostrarInfo() {  // Método de la clase para mostrar información de los alumnos
    console.log(`Nombre: ${this.nombre}, Edad: ${this.edad}`);
  }
}

// Creación de un objeto alumno1 de la clase Alumnos
let alumno1 = new Alumnos('Ander', 15); //pasamos argumentos para nuestros parámetros

// Llamada al método mostrarInfo del objeto alumno1
alumno1.mostrarInfo(); // Imprime: Nombre: Ander, Edad: 15
```

**Explicación**

Concretamente en JS, las clases se declaran utilizando la palabra reservada class, seguida del nombre de la clase: **class Alumnos **

Dentro de ella se define el constructor, que sería equivalente al método dunder __ init__ en python. Este método contiene tantos parámetros como atributos(características) pretendemos que contengan nuestros objetos/instancias.

Luego, dentro del constructor, creamos nuestros atributos, utilizando la palabra this, punto, y el nombre del atributo y al parámetro correspondiente: **this.nombre = nombre;**. 

En principio, con esos pasos ya hemos declarado nuestra clase y hemos definido el constructor, por lo que ya podríamos crear instancias, que son objetos pertenecientes a esa clase. En nuestro ejemplo aún no lo haremos, ya que deseamos agregar un comportamiento que se aplique a esas instancias.

Ahora crearemos un método. Este es un ejemplo muy simple en el que sólo queremos que se imprima un template literal que sustituya los atributos **${this.nombre}** y **${this.edad}** por los argumentos que pasemos más adelante para el objeto que creemos.

Hecho esto, una vez fuera de la clase ya podemos crear nuestro objeto. Para ello crearemos una variable y le asignaremos la clase a la que pertenece, precedida de la palabra new, y entre paréntesis los argumentos correspondientes: **let alumno1 = new Alumnos('Ander', 15);**

Finalmente, podemos llamar método para que se aplique a la instancia de objeto que hemos creado: **alumno1.mostrarInfo()**.

### Objetos: 

Tal como lo hemos mencionado previamente, los objetos son instancias de una clase. En nuestro ejemplo anterior, son instancias de la clase Alumnos. Esos objetos representan entidades concretas que tienen características específicas definidas por su clase (atributos). En nuestro ejemplo anterior: **let alumno1 = new Alumnos('Ander', 15);** representa un alumno con un nombre y una edad.

En el ejemplo anterior hemos visto que es posible aplicar un método a una instancia(objeto), para ello solo debo usar el nombre del objeto, seguido de un punto '.' y del nombre del método con sus paréntesis: **alumno1.mostrarInfo()**

También hemos visto que el objeto **alumno1** posee dos propiedades: nombre y edad. Si yo quisiera acceder a ellas, por ejemplo, imprimirlas sólo tendría que indicar de dentro del objeto, a qué atributo quiero acceder. Para ellos sólo tengo que indicar el nombre del objeto, un punto '.' y el atributo que deseo imprimir: console.log(**persona1.nombre**);

### 4 principios de la Programación Orientada a Objetos

- Encapsulación:

Se refiere a agrupar los datos (atributos) y funciones (métodos) relacionados en un objeto y controlar cómo se accede y se modifica esa información desde fuera del objeto.

En POO la encapsulación implica el uso de modificadores de acceso y buenas prácticas de diseño. En JS concretamente se logra mediante el uso de funciones constructoras, el uso de métodos para acceder y modificar atributos, y el uso de convenciones de nomenclatura para indicar la visibilidad de los elementos de una clase. En Python, por ejemplo, contamos con modificadores de acceso como el guion bajo antes del nombre de un atributo para indicar que era un atributo protegido, o el doble guion bajo antes del atributo para evitar que se modifique ese atributo: **__ self.atributo**.

- Abstracción:

Cuando un usuario interactúa con un objeto en un sistema basado en POO, por ejemplo una red social, se enfoca en utilizar métodos y atributos específicos que son relevantes para la tarea que quiere realizar, sin necesidad de conocer todos los detalles complejos de cómo funciona el objeto internamente.

En el caso de la red social, el usuario se encuentra con una interfaz simplificada, los campos de nombre de usuario y contraseña son todo lo que necesita para interactuar con el sistema y completar la tarea de registro. Detrás de escena, existen métodos que se encargan de gestionar todo lo necesario para crear la cuenta de forma segura y eficiente.

Esta abstracción permite al usuario trabajar con herramientas de alto nivel de manera fácil e intuitiva, ocultando la complejidad del objeto (en este caso, la gestión de bases de datos, encriptación de contraseñas, etc). Gracias a esto, el usuario puede enfocarse en la tarea principal sin distraerse con detalles técnicos complicados y tener una mejor experiencia de usuario.

- Herencia:
![Img](Images/dogshow.jpg)

En Pjpgoo la herencia es un principio fundamental. Este permite crear nuevas clases en función de clases ya existentes, lo cual permite la reutilización del código, a la vez que establece una jerarquía entre las diferentes clases. Esas clases están relacionadas por lo que si bien tienen sus características específicas, también comparten características comunes.

Respecto a este tema se puede hablar de dos tipos de clases:

1. Las Clases Base (clases Padre o Superclase): Que son las clases originales a partir de las cuales pueden heredar las otras clases.
2. Las clases Derivadas (Clases Hijas o Subclases): Estas son las que heredan atributos y métodos de la clase base. Esto no quita que también puedan tener sus atributos y métodos propios.

- Polimorfismo:

El polimorfismo es un concepto de la programación orientada a objetos que permite que objetos de distintas clases sean tratados de manera homogénea. Esto significa que a diferentes instancias de objeto puede aplicarse una misma función que proporcionará comportamientos diferentes, ya que estos dependerán de los atributos de cada objeto. 

Dicho de otra forma, el polimorfismo permite que diferentes instancias de una clase respondan de manera específica a una misma llamada de método, lo que devuelve comportamientos distintos según las características y funcionalidades de cada objeto en particular.

O sea, que si yo creo dos clases diferentes y dentro de ellas un método del mismo nombre, al llamar a ese método fuera de las clases, las instancias de objeto de ambas responderán a esa llamada, cada una con el comportamiento que se haya determinado en su método (comparten nombre, no necesariamente comportamiento) y los atributos de sus instancias.

**Veamos un ejemplo:**

```python
# Definición de dos clases con un método del mismo nombre
class Perro:
    def sonido(self): # método del mismo nombre
        return "Guau!" # comportamiento diferente

class Gato:
    def sonido(self): # método del mismo nombre
        return "Miau!" # comportamiento diferente

# Función que utiliza polimorfismo
def emitir_sonido(animal): # el parámetro hará referencia a la instancia de clase
    return animal.sonido() # indico que mi función se ejecute en ese objeto. Devuelve el sonido asociado a cada objeto

# Creo una instancia para cada clase
mi_perro = Perro()
mi_gato = Gato()

# Llamada a la función con diferentes instancias
print(emitir_sonido(mi_perro))  # Salida: Guau!
print(emitir_sonido(mi_gato))   # Salida: Miau!
```

## 7. ¿Qué es una promesa en JS?

Cuando trabajamos con operaciones asíncronas esperamos un resultado, ya sea que la operación resulte exitosa, fracase o esté pendiente. Ese resultado de esa operación que hemos realizado se representa mediante un objeto llamado promesa.

Por ejemplo, cuando realizas una transferencia bancaria online, el banco nos facilita un comprobante de que hemos realizado esa operación. Esto es similar a una promesa en JS. La promesa sería como el recibo de transferencia, donde se nos informa que se realizará una operación. Nosotros, por nuestro lado, ya hemos cumplido con todos los procedimientos necesarios.

Una vez realizada la transferencia(o creada la promesa) pueden ocurrir tres cosas:

- Éxito: Que la transferencia resulte exitosa y nuestra transferencia se haga sin problemas. O sea, que se cumpla nuestra promesa. En este caso decimos que se resuelve la promesa.

- Fracaso: Que nuestra transferencia no se realice, sea porque no hemos dado los datos correctos, o un problema en la red. En ese caso diríamos que la promesa ha sido rechazada.

- Pendiente: Que nuestra transferencia esté pendiente, por ejemplo, porque necesita la aprobación del beneficiario, de nuestro banco, o del banco que la recibe. Este sería el estado pendiente de una promesa.

**Operaciones síncronas y asíncronas**

Como hemos mencionado previamente, las operaciones asíncronas nos permiten realizar promesas. Pero, ¿qué es una operación asíncrona? 

Para entenderlo debemos primero hablar de operaciones síncronas, que son tareas que se ejecutan una tras otra de manera secuencial. La no realización de una tarea, bloqueará la ejecución de la siguiente. Son tareas que se ejecutan de forma lineal, donde cada una depende de la anterior. Por ejemplo, para poder acceder a mi correo, antes necesito iniciar sesión con mi usuario y contraseña, luego ya puedo realizar esa tarea. Esas dos actividades, iniciar sesión y revisar el correo son síncronas. Una depende de que se haya completado la otra.

Las operaciones asíncronas, en cambio, no presentan este problema y pueden ser realizadas al mismo tiempo sin que una bloquee la ejecución de la otra. Podemos decir que una se ejecuta de fondo, mientras la otra está visible. Por ejemplo, si pretendemos cargar imágenes a un sitio web, esta tarea posiblemente tarde un tiempo, en especial dependiendo del número de fotos que intentemos subir. Esta tarea generará una promesa y se ejecutará de fondo. Mientras eso sucede, el sitio web nos dejará navegar, acceder a nuestros mensajes, o hacer lo que haga falta. Una vez que las fotos se hayan cargado recibiremos un mensaje que nos lo indique (o que ha fracasado el proceso, por ejemplo).

Un ejemplo más habitual podría ser Whatsapp. Cuando enviamos un audio o una foto, hay ocasiones en las que la foto se envía prácticamente de manera instantánea, en ese caso sabemos que nuestra promesa ha sido exitosa. Hay otros momentos en los que podemos ver claramente como nuestro audio o foto se está enviando y aún no ha sido recibido por la otra persona, esa operación está pendiente. Finalmente, puede ocurrir que nuestro audio o foto no se envíe (como cuando tenemos mala conexión) y Whatsapp nos muestre un mensaje que dice 'inténtelo de nuevo', en ese caso nuestra promesa ha fracasado. 

Como podemos apreciar, las promesas generan una mejor experiencia de usuario. Como usuarios sabremos lo que está ocurriendo con las operaciones que hemos realizado. Sabremos si se han cumplido, si están pendientes o incluso si han fallado, en lugar de simplemente realizarse o fallar silenciosamente.

## Cómo crear una promesa

La sintaxis para crear una promesa es la siguiente:

```js
let myPromise = new Promise((resolve, reject) => { //myPromise es una instancia de la clase Promise 
  setTimeout(() => { 
    resolve('Hola....'); //si en 2 segundos la solicitud es exitosa la respuesta será "Hola"
  }, 2000);

  setTimeout(() => { 
    reject(Error('Intente de nuevo más tarde...'));//si en 2 segundos la solicitud no es exitosa, esta será la respuesta
  }, 2000);
});

myPromise //llamada como si llamara a una función, la convención en promesas es usar varias líneas
  .then(data => {//then es una palabra reservada que la promesa espera
    console.log(data);
  })
  .catch(err => { //then es una palabra reservada que la promesa espera
    console.error(err);
  });
```
**¿Qué está ocurriendo?**

```js
let myPromise = new Promise((resolve, reject) => { //myPromise es una instancia de la clase Promise 
  setTimeout(() => { 
    resolve('Hola....'); //si en 2 segundos la solicitud es exitosa la respuesta será "Hola"
  }, 2000);

  setTimeout(() => { 
    reject(Error('Intente de nuevo más tarde...'));//si en 2 segundos la solicitud no es exitosa, esta será la respuesta
  }, 2000);
});
```

- Primero creamos una instancia **myPromise** de la clase Promise, esta será nuestra promesa. **new Promise** es un constructor que crea un nuevo objeto de tipo promesa.

- Ahora, dentro de esa nueva promesa, entre paréntesis, para determinar el comportamiento de esa promesa utilizaremos una función, en este caso una función de flecha que toma dos parámetros: resolve, que representa el éxito de nuestra promesa, y reject que representa su fracaso.

- Dentro de esa función de flecha vamos a determinar dos comportamientos, uno para cuando nuestra promesa se resuelve en 2 segundos, y otro para cuando fracasa en ese mismo tiempo. Para cada uno de ellos utilizaremos dos métodos **setTimeout**.

- **setTimeout** requiere 3 parámetros: una función que se ejecuta cuando expira el temporizador, en este caso nuestra función de flecha. **resolve** o **reject** (pasados anteriormente como parámetros) y el mensaje que deben generar. Un tiempo en milisegundos, que representa el tiempo que debe pasar antes de que se ejecute la función.

Hasta aquí hemos creado la primera parte de nuestra promesa, lo que sigue nos ayudará a manejar el resultado obtenido.

```js
myPromise 
  .then(data => {
    console.log(data);
  })
  .catch(err => { //then es una palabra reservada que la promesa espera
    console.error(err);
  });
```

- Primero llamamos a la promesa **myPromise** que habíamos creado.

- Utilizamos el método **then**, que sirve para manejar las promesas exitosas.

- **data** es el nombre de una variable, no es una palabra reservada. Aquí lo que indicamos es que tras resolverse la promesa de manera exitosa, se asigna ese valor a data automáticamente y se imprime. 

- Para gestionar las promesas rechazadas utilizaremos el método **catch**. Este funcionará exactamente como el anterior con la diferencia de que se encargará de las promesas rechazadas y lo que asignará a la variable e imprimirá será el mensaje de error que hemos creado anteriormente.


## 8. ¿Qué hacen async y await por nosotros?

Async y Await son características de Javascripr que se utilizan para trabajar con código asíncrono. Estas simplifican tanto la escritura como la gestión de este tipo de código, y facilitan especialmente el trabajo con promesas.

Async, await y las promesas son conceptos relacionados y complementarios cuando se trabaja con código asíncrono. Tienen la ventaja de que no bloquean el código mientras sus operaciones se resuelven

Ya hemos visto las promesas y como estas hacen más fácil trabajar con código asíncrono. Ahora veremos cómo funcionan async y await.

### Async:

Se trata de una palabra reservada que se utiliza para declarar una función asíncrona . Esto significa que el código que ejecute será asíncrono, tomará algún tiempo y se hará de fondo, sin bloquear la ejecución de otras tareas. Esta función siempre retorna una promesa, que puede ser exitosa o rechazada.

### Await:

Dentro de la función **async** podemos utilizar la palabra reservada **await**. Await se utiliza para pausar la ejecución de la función async en lo que espera a que la promesa se resuelva o se rechace y así permitir que el resto de tareas puedan seguir ejecutándose con normalidad.

### Cómo funciona:

Comenzaremos por crear dos promesas, en este caso utilizaremos primero será un inicio de sesión y luego la actualización de los datos. Claramente, una debe ocurrir antes que la otra, en este caso el inicio de sesión, por lo que la actualización deberá esperar a que esta se realice. 

```js
const login = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('User logged in...');
    }, 2000);
  });
}

const updateAccount = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Updating last login...');
    }, 2000);
  });
}
```
El usuario, sin embargo, no suele ver que esos dos procesos se están realizando, simplemente ingresa sus datos y ve su sesión. Estas dos promesas se presentan al usuario como una única operación.

Ahora veamos cómo ocurre esto:

```js
async function loginActivities() {
  const returnedLogin = await login();
  console.log(returnedLogin);

  const returnedUpdateAccount = await updateAccount();
  console.log(returnedUpdateAccount);
}

loginActivities();
```
Primero creamos la utilizamos la palabra reservada async, que como vimos antes indica que la función **loginActivities()** será una función asíncrona y que podremos usar await dentro de ella. 

Luego, dentro de esa función indicaremos los comportamientos que esperamos. Para ello crearemos dos variables.

La primera variable será **returnedLogin**. Dentro de ella utilizaremos **await** para esperar a que se resuelva el **login** de nuestra primera promesa antes de pasar a la siguiente. Esto se realiza de manera síncrona, primero se resuelve la primera promesa (login) y luego continúa ejecutándose nuestra función asíncrona loginActivities(). Una vez que nuestra primera promesa se resuelva, es decir, que sea exitosa, el valor retornado se almacenará en esta variable y nuestra función asíncrona loginActivities() podrá seguir ejecutando su código.

La segunda variable, **returnedUpdateAccount**, también utilizará  **await** para la promesa updateAccount y esperará a que esta se resuelva o se rechace. Si la promesa ha sido resuelta almacenará el valor retornado en esta variable y el código seguirá ejecutándose.

Esto significa que tras realizar nuestras promesas, con async hemos indicado a nuestro código que independiente de qué promesa se resuelva primero, el código debe respetar ese orden de ejecución.

Primero espera a que se resuelva la promesa login y almacene esos datos en la variable que he creado. Hasta que no se cumpla esto, el resto de mi código estará "en pausa" o esperando para ejecutarse. Una vez hecho esto pasaré a la siguiente promesa y sucederá lo mismo, y sólo cuando esta se haya resuelto se ejecutará la llamada a la función.

Básicamente, await indica que debo esperar a que se resuelva algo antes de que mi código pueda continuar ejecutándose:
- await login(): debo esperar a que se resuelva la promesa login.
- await updateAccount(): debo esperar a que se resuelva la promesa updateAccount.


Fuentes consultadas:

https://codingpotions.com/javascript-diferencia-var-let-const

https://medium.com/@codingsam/awesome-javascript-no-more-var-working-title-999428999994

https://www.w3schools.com/js/js_hoisting.asp

https://www.freecodecamp.org/espanol/news/desestructuracion-de-arreglos-y-objetos-en-javascript/

https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

https://coffeebytes.dev/es/desestructuracion-de-objetos-anidados/

https://universidadeuropea.com/blog/programacion-orientada-objetos/

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise

https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

https://es.javascript.info/promise-basics

https://developer.mozilla.org/es/docs/Web/API/setTimeout

https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/async_function

https://es.javascript.info/async-await

https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Loops_and_iteration#declaracion_for

https://www.freecodecamp.org/espanol/news/javascript-bucles-explicados-for-while-loops/

https://intelequia.com/es/blog/post/qu%C3%A9-es-la-programaci%C3%B3n-orientada-a-objetos

https://learn.microsoft.com/es-es/shows/csharp-for-beginners/oop-with-derived-or-abstract-classes-overrides-ienumerable-csharp-for-beginners

https://learn.microsoft.com/es-es/dotnet/visual-basic/programming-guide/concepts/object-oriented-programming#inheritance

Guías DevCamp

Agradecimientos imágenes:

https://www.freepik.es

<a href="https://www.freepik.es/vector-gratis/programadores-que-utilizan-lenguaje-programacion-javascript-computadora-gente-pequena-lenguaje-javascript-motor-javascript-concepto-desarrollo-web-js-ilustracion-aislada-violeta-vibrante-brillante_10782951.htm#fromView=search&page=1&position=11&uuid=d8f2e366-dbd7-4344-bf73-fa3f9315a262">Imagen de vectorjuice en Freepik</a>


https://pixabay.com/es/photos/exposici%C3%B3n-perro-pelo-largo-3804522/  Sonja-Kalee







